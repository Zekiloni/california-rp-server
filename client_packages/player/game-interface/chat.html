<!DOCTYPE html>
<html>
<head>
   <!-- meta tags-->
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

   <!-- source -->
   <link rel="stylesheet" type="text/css" href="src/vendor/css/fonts.css" />
   <link rel="stylesheet" type="text/css" href="src/vendor/css/font-awesome.css" />

   <link rel="stylesheet" type="text/css" href="src/styles/chat.css" />

</head>
<body>
   <div id="chat" v-if="Toggle">

      <transition-group name="message" tag="ul" class="messages" ref="Entries" id="messages">
         <li v-for="(message, i) in Messages" class="message" v-bind:style="{ fontSize: Settings.Fontsize + 'px', fontWeight: Settings.Fonweight, opacity: Inactive ? '0.5' : '1' }" v-bind:key="message">
            
            <b class="timestamp" v-if="Settings.Timestamp" v-html="DateTime(message.timestamp)"> </b>
            <span v-html="message.content"> </span>
             
         </li>
      </transition-group>

      <transition name="slide-fade">
         <div class="input-form" v-if="Typing">
            <input
              placeholder="SadrÅ¾aj."
              v-model="Input"
              type="text"
              class="chat-input"
              ref="ChatInput"
              class="form-control rounded-0"
              maxlength="200"
              @keyup.esc="Close"
              @keyup.up="GoHistory(1)"
              @keyup.down="GoHistory(0)"
            >
            <div class="currentLength"> {{ Input.length + ' / 200'}} </div>
         </div>
      </transition>

   </div>
      
   <!-- scripts -->
   <script src="src/vendor/js/vue.js"></script>
   <script>

      let chat = new Vue({
         el: '#chat',
         data: {      
            Toggle: true,

            Typing: false,
            Input: '',

            Controllable: true,

            Inactive: false,
            
            Settings: { 
               Fontsize: 17.5,
               Fonweight: 700,
               Width: 300,
               Height: 200,
               Timestamp: false,
            },

            Current: -1,

            History: [

            ],
           
            Messages: [

            ]
         },

         watch: {
            Messages: function (value) {
               this.Update();
            }
         },

         methods: { 

            Activate: function (toggle) { 
               if (this.Typing) this.Typing = false, this.Input = '';
               this.Controllable = toggle;
            },

            ToggleInput: function (toggle) { 
               this.Typing = toggle;
               mp.invoke('focus', toggle);
               if (toggle) { 
                  mp.invoke('setTypingInChatState', true);
                  Vue.nextTick(function() { this.$refs.ChatInput.focus(); }.bind(this));
               } else { 
                  mp.invoke('setTypingInChatState', false);
                  this.$refs.ChatInput.blur();
                  this.Input = '';
               }
            },

            Close: function () { 
               if (this.Toggle && this.Controllable && this.Typing) { 
                  this.ToggleInput(false);     
               }
            },

            Push: function (content, type = null) {

               if (content.includes('color')) { 
                  console.log('COLORRR ISs')
                  let span = content.split('"');
                  let color = span[1].split(' ');
                  content.replace(color[1], '#' + color[1]);
               }
               console.log(content)

               const message = { timestamp: Date.now(), content: content, type: type }
               this.Messages.push(message);
            },

            Send: function () {
               let content = this.Input;
               this.ToggleInput(false);

               if (content && content.length > 0) {
                  this.History.unshift(content);

                  if (content[0] == '/') {
                     content = content.substr(1);
                     mp.invoke('command', content);
                  } else if (content.includes('timestamp')) { 
                     this.Settings.Timestamp = !this.Settings.Timestamp;
                  } else {
                     mp.invoke('chatMessage', content);
                  }

                  this.Current = -1
               }
            },


            Show: function (toggle) { 
               this.Toggle = toggle;
            },

            Check: function () { 

               const Now = new Date();
               if (this.Messages.length > 0) {
                  const LastMessage = this.Messages[this.Messages.length -1];
                  const Last = new Date(LastMessage.timestamp);

                  const diff = (Now.getTime() - Last.getTime()) / 1000;;
                  if (diff > 60) { 
                     this.Inactive = true;
                  } else { 
                     this.Inactive = false;
                  }
               }

               setTimeout(() => { this.Check(); }, 1500);
            },

            GoHistory: function (d) {
               if (this.History.length == 0) return;

               let Previous = null;

               switch (d) {
                  case 0: {
                     if (this.Current == -1) return;
                     this.Current --;
                     if (this.History[this.Current]) { 
                        Message = this.History[this.Current];
                     } else { 
                        Message = '';
                     }
                     break;
                  }

                  case 1: { 
                     if (this.Current == this.History.length -1) return;
                     this.Current ++;
                     Message = this.History[this.Current];
                     break;
                  }
               }

               this.Input = Message;
            },

            Update: function () { 
               this.Scroll();
               // this.$refs.Entries.scrollTop = this.$refs.Entries.offsetHeight;
               // this.$refs.Entries.scrollTo({ top: this.$refs.Entries.offsetHeight, behavior: 'smooth' })
            },

            Clear: function () { 
               this.Messages = [];
            },

            Scroll: function () {
               const Element = document.getElementById('messages');

               let height = Element.clientHeight;
               let scrollHeight = Element.scrollHeight - height;
               let scrollTop = Element.scrollTop;
               let percent = Math.floor(scrollTop / scrollHeight * 100);

               Element.scroll({
                  top: Element.scrollHeight,
                  behavior: 'smooth'
               });
               //Element.scrollTop = Element.scrollHeight - Element.clientHeight;
               // return Element;
            },

            DateTime: function (timestamp) { 
               const date = new Date(timestamp);
               return date.getHours() + ':' + (date.getMinutes() < 10 ? '0' : '') + date.getMinutes() + ':' + (date.getSeconds() < 10 ? '0' : '') + date.getSeconds();
            },

            SetFontsize: function (i) { 
               if ( i < 11 || i > 19) return;
               this.Settings.Fontsize = i;
            }
         },

         mounted () {

            this.Push('Focus Roleplay - www.focus-rp.com');
            this.Check();
            
            document.addEventListener('keyup', function (e) { 
               switch (e.keyCode) {
                  case 84: { 
                     if (chat.Typing) return;
                     if (chat.Toggle && chat.Controllable) {
                        chat.ToggleInput(chat.Typing = !chat.Typing);
                     }
                     break;
                  }

                  case 13: {
                     if (chat.Toggle && chat.Typing) {
                        chat.Send();
                     }
                     break;
                  }
               }
            });
         }
      });


      let chatAPI = { 
         push: (content) => { chat.Push(content) },
         clear: ( ) => { chat.Clear(); },
         activate: (toggle) => { chat.Activate(toggle); },
         show: (toggle) => { chat.Show(toggle) }
      }; 

      const events = {
         'chat:push': chatAPI.push, 'chat:clear': chatAPI.clear,
         'chat:activate': chatAPI.activate, 'chat:show': chatAPI.show
      }

      for (let i in events) { mp.events.add(i, events[i]); }

   </script>
</body>     
</html>
